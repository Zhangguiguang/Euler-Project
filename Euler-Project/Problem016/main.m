//
//  main.m
//  Problem016
//
//  Created by 张贵广 on 15/9/20.
//  Copyright (c) 2015年 HZNU. All rights reserved.
//
/*
 
 幂的数字和
 
 2^15 = 32768，而32768的各位数字之和是 3 + 2 + 7 + 6 + 8 = 26。
 
 2^1000的各位数字之和是多少？
 
 // 在mac的计算器上计算 2^1000 = '不是数字'，很显然，这个数字很大，只能自己用方法计算
 // (2^10)^100 = 1024^100 < 10000^100 < 10^400 ，显然400位够用了
 // 虽然一个单数字不超过10，但这500位我还是要用int，
 // 计算1000次 ×2计算 ,可以化成40次 ×2^25，而吸取Problem的经验，×2^25可换成 <<25
 
 // 运算结果：sum = 1366
 // 虽然后来把power换成1，times = 1000，运算速度也很快，但，在int的取值范围内，当然是times次数越少越好
 
 */

#import <Foundation/Foundation.h>

#define MAX_LENGTH 400
#define POWER 25    // 一次计算 ×2^25
#define TIMES 40    // 1000/POWER

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        int result[MAX_LENGTH] = {1};
        int i, j;
        
        // 数组里面存的数字反着存，0位存个位，1位存十位。。。。，先初始化
        for (i=1; i<MAX_LENGTH; i++) {
            result[i] = 0;
        }
        
        for (i=0; i<TIMES; i++) {
            for (j=0; j<MAX_LENGTH; j++) {  // 先把这400位各自 ×2^power
                result[j] <<= POWER;
            }
            for (j=0; j<MAX_LENGTH-1; j++) {  // 再计算进位，这两步不可在一个循环里
                // j<MAX_LENGTH-1，因为循环里要用到高位j+1,防止resulr[MAX_LENGTH]下标越界，而且第400位也用不到
                result[j+1] += result[j]/10;
                result[j] %= 10;
            }
        }
        
        int sum = 0;
        for (i=MAX_LENGTH-1; i>=0; i--) {
            sum += result[i];
            printf("%i", result[i]);
        }
        printf("\n");
        /*
         输出结果
         0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376
         
         */
        
        NSLog(@"sum = %i", sum);
    }
    return 0;
}
