//
//  main.m
//  Problem156
//
//  Created by 张贵广 on 16/8/5.
//  Copyright © 2016年 GG. All rights reserved.
//

/*
 数字计数
 http://pe-cn.github.io/156/
 */

/*
 经过测试
 f(1111111110, 1) = 1111111110
 而此时，s(1)=22786974071，符合题目给出的条件
 那么估计，要计算 1 ≤ d ≤ 9，∑ s(d)
 计算的终点大概可能是 1111111110 * 9 ≈ 100亿
 ... 计算机吃不消了。
 
 上面的估计不靠谱，换一种方式估计。
 假设计算的终点是 m位数=n，所有数字都有前置0，那么一直到n，得到所有数字的个数为 n*m,
 这些数字中0-9基本上是平分的，每种数字 ≈ m*n/10个
 当每一种数字个数 > 当前数字n时，也就是计算终点了。
 即 m*n/10 > n， 那么 m > 10, 即 当数字个数统计到 100亿，就没有必要计算下去了。
 
 计算机吃不消，计算机空转100亿需要20s，如果每次循环所需要的时间能尽可能小，就能大大减少运行时间。
 之前直接拿到一个数字，模10取余得到每位上的数字。小数字运行毫无压力。
 
 现在打算用一个数组来计数，用11位长度，每个元素代表一个位，当最高位=1(计算到了100亿)，
 虽然会有大量进十操作，但进一次十，到下一次进十，比起中间的数字过大时分解几十次，进十操作显得不是那么
 假设计数到 10000， 进十的次数有 1111=o(0.1n), 而分解需要 10+2*90+3*900+4*9000=38890=o(4(位数)*n)
 
 结果新算法计算到1111111110(11亿)时，只用了34s，比起那个慢的算法，快太多了，30s计算了十分之一，
 那么计算到终点，大概需要5分钟，实际情况，花了6分钟得出结果
 
 再结果，得到的答案是错误的。。。似乎是终点估计错误，我计算的范围还是小了。
 仔细思考，实际需要
 m*n > 10n + n
 那么m>11, 要计算到1000亿啊。。。晕，那估计要运行1小时才有结果了。。
 
 2016-08-07 01:33:42.383 Problem156[2523:36279] f(0, 1) = 0
 ......
 2016-08-07 01:33:43.500 Problem156[2523:36279] f(35199990, 1) = 35199990
 2016-08-07 01:33:43.500 Problem156[2523:36279] f(35200000, 1) = 35200000
 2016-08-07 01:33:43.500 Problem156[2523:36279] f(35200001, 1) = 35200001
 ......
 2016-08-07 01:33:57.380 Problem156[2523:36279] f(500199984, 1) = 500199984
 2016-08-07 01:33:57.380 Problem156[2523:36279] f(500199985, 1) = 500199985
 2016-08-07 01:33:57.380 Problem156[2523:36279] f(500199986, 1) = 500199986
 ......
 2016-08-07 01:33:58.440 Problem156[2523:36279] f(535200001, 1) = 535200001
 2016-08-07 01:34:16.232 Problem156[2523:36279] f(1111111110, 1) = 1111111110
 2016-08-07 01:39:08.009 Problem156[2523:36279] f(9465000000, 7) = 9465000000
 2016-08-07 01:39:08.009 Problem156[2523:36279] f(9465000000, 8) = 9465000000
 ......
 2016-08-07 01:39:25.078 Problem156[2523:36279] f(9998399997, 8) = 9998399997
 2016-08-07 01:39:25.129 Problem156[2523:36279] f(10000000000, 2) = 10000000000
 2016-08-07 01:39:25.129 Problem156[2523:36279] f(10000000000, 3) = 10000000000
 2016-08-07 01:39:25.129 Problem156[2523:36279] f(10000000000, 4) = 10000000000
 2016-08-07 01:39:25.129 Problem156[2523:36279] f(10000000000, 5) = 10000000000
 2016-08-07 01:39:25.129 Problem156[2523:36279] f(10000000000, 6) = 10000000000
 2016-08-07 01:39:25.129 Problem156[2523:36279] f(10000000000, 7) = 10000000000
 2016-08-07 01:39:25.129 Problem156[2523:36279] f(10000000000, 8) = 10000000000
 2016-08-07 01:39:25.129 Problem156[2523:36279] f(10000000000, 9) = 10000000000
 2016-08-07 01:39:25.129 Problem156[2523:36279] s(1) = 22786974071
 2016-08-07 01:39:25.129 Problem156[2523:36279] s(2) = 11868991481
 2016-08-07 01:39:25.129 Problem156[2523:36279] s(3) = 14215999875
 2016-08-07 01:39:25.129 Problem156[2523:36279] s(4) = 15499999885
 2016-08-07 01:39:25.129 Problem156[2523:36279] s(5) = 10000000000
 2016-08-07 01:39:25.129 Problem156[2523:36279] s(6) = 115783999905
 2016-08-07 01:39:25.129 Problem156[2523:36279] s(7) = 68131008510
 2016-08-07 01:39:25.129 Problem156[2523:36279] s(8) = 419040935919
 2016-08-07 01:39:25.130 Problem156[2523:36279] s(9) = 10000000000
 2016-08-07 01:39:25.130 Problem156[2523:36279] sum = 687327909646
 
 
 */

#import <Foundation/Foundation.h>
#define MAX_LENGTH 10000000000
#define DIGIT 10
#define COUNT 11


void slow() {
    long digitCount[10] = {0};
    long s[10] = {0};
    
    for (long i=1; i<MAX_LENGTH; i++) {
        long num = i;
        while (num > 0) {
            digitCount[num%10]++;
            num /= 10;
        }
        for (int j=1; j<10; j++) {
            if (digitCount[j] == i) {
                NSLog(@"f(%ld, %d) = %ld", i, j, i);
                s[j] += i;
            }
        }
    }
    
    long sum = 0;
    for (int i=1; i<10; i++) {
        sum += s[i];
        NSLog(@"s(%d) = %ld", i, s[i]);
    }
    
    NSLog(@"sum = %ld", sum);
}

void fast() {
    
    long digitCount[DIGIT] = {0};
    int  n[COUNT] = {0};
    int  m = 1; // 数字n的位数
    long s[DIGIT] = {0};
    
    int i = 0; // 空间开辟还是拿到外面来好
    long num = 0;
    for (; num<=MAX_LENGTH; n[0]++, num++) {
        // 先判断进位
        for (i=0; i<COUNT-1; i++) {
            if (n[i] >= 10) {
                n[i+1]++;
                n[i] -= 10;
                if (i+1 == m) m++; // 如果当前最高位满十进位，那么总位数增加
            }
            else {
                // 进位结束
                break;
            }
        }
        
        // 数字统计
        for (i=0; i<m; i++) {
            digitCount[n[i]]++;
        }
        
        
        for (i=1; i<DIGIT; i++) {
            if (digitCount[i] == num) {
                NSLog(@"f(%ld, %d) = %ld", num, i, num);
                s[i] += num;
            }
        }
    }
    
    
    long sum = 0;
    for (int i=1; i<10; i++) {
        sum += s[i];
        NSLog(@"s(%d) = %ld", i, s[i]);
    }
    
    NSLog(@"sum = %ld", sum);
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
//        slow();
        fast();
    }
    return 0;
}
