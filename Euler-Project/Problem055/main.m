//
//  main.m
//  Problem055
//
//  Created by 张贵广 on 16/8/25.
//  Copyright © 2016年 GG. All rights reserved.
//

/*
 利克瑞尔数
 将47倒序并相加得到47 + 74 = 121，是一个回文数。
 
 不是所有的数都能像这样迅速地变成回文数。例如，
 349 + 943 = 1292
 1292 + 2921 = 4213
 4213 + 3124 = 7337
 也就是说，349需要迭代三次才能变成回文数。
 尽管尚未被证实，但有些数，例如196，被认为永远不可能变成回文数。如果一个数永远不可能通过倒序并相加变成回文数，就被称为利克瑞尔数。出于理论的限制和问题的要求，在未被证否之前，我们姑且就认为这些数确实是利克瑞尔数。除此之外，已知对于任意一个小于一万的数，它要么在迭代50次以内变成回文数，要么就是没有人能够利用现今所有的计算能力将其迭代变成回文数。事实上，10677是第一个需要超过50次迭代变成回文数的数，这个回文数是
 4668731596684224866951378664（53次迭代，28位数）。
 令人惊讶的是，有些回文数本身也是利克瑞尔数数；第一个例子是4994。
 小于一万的数中有多少利克瑞尔数？
 注意：2007年4月24日，题目略作修改，以强调目前利克瑞尔数理论的限制。
 */

/*
 这个问题的关键不是计算量，而是防止溢出，
 1xxx9 + 9xxx1 = 1xxxx0, 这个数字会扩大10倍，虽然并不是每次迭代都扩大10倍，但经过50次迭代，一个long肯定装不下。
 就按最大扩大10倍算，数字最后会有不超过50位数。
 
 计算中，每计算一个数，得到另一个倒序的数，完全可以把它们看做相同的数，47和74，它们的计算步骤，结果完全相同。
 先计算了47，之后遇到74，完全可以用47的结果来标记它。
 XXXX 这招会导致错误的结果， 196是利克瑞尔数, 但6910不是，所以还是老老实实，一个一个数的计算。
 
 196, 295, 394, 493, 592, 689, 691, 788, 790, 879, 887, 978, 986, 1495, 1497, 1585, 1587, 1675, 1677, 1765, 1767, 1855, 1857, 1945, 1947, 1997, 2494, 2496, 2584, 2586, 2674, 2676, 2764, 2766, 2854, 2856, 2944, 2946, 2996, 3493, 3495, 3583, 3585, 3673, 3675, 3763, 3765, 3853, 3855, 3943, 3945, 3995, 4079, 4169, 4259, 4349, 4439, 4492, 4494, 4529, 4582, 4584, 4619, 4672, 4674, 4709, 4762, 4764, 4799, 4852, 4854, 4889, 4942, 4944, 4979, 4994, 5078, 5168, 5258, 5348, 5438, 5491, 5493, 5528, 5581, 5583, 5618, 5671, 5673, 5708, 5761, 5763, 5798, 5851, 5853, 5888, 5941, 5943, 5978, 5993, 6077, 6167, 6257, 6347, 6437, 6490, 6492, 6527, 6580, 6582, 6617, 6670, 6672, 6707, 6760, 6762, 6797, 6850, 6852, 6887, 6940, 6942, 6977, 6992, 7059, 7076, 7149, 7166, 7239, 7256, 7329, 7346, 7419, 7436, 7491, 7509, 7526, 7581, 7599, 7616, 7671, 7689, 7706, 7761, 7779, 7796, 7851, 7869, 7886, 7941, 7959, 7976, 7991, 8058, 8075, 8079, 8089, 8148, 8165, 8169, 8179, 8238, 8255, 8259, 8269, 8328, 8345, 8349, 8359, 8418, 8435, 8439, 8449, 8490, 8508, 8525, 8529, 8539, 8580, 8598, 8615, 8619, 8629, 8670, 8688, 8705, 8709, 8719, 8760, 8778, 8795, 8799, 8809, 8850, 8868, 8885, 8889, 8899, 8940, 8958, 8975, 8979, 8989, 8990, 9057, 9074, 9078, 9088, 9147, 9164, 9168, 9178, 9237, 9254, 9258, 9268, 9327, 9344, 9348, 9358, 9417, 9434, 9438, 9448, 9507, 9524, 9528, 9538, 9597, 9614, 9618, 9628, 9687, 9704, 9708, 9718, 9777, 9794, 9798, 9808, 9867, 9884, 9888, 9898, 9957, 9974, 9978, 9988, 9999,
 count = 249
 */

#import <Foundation/Foundation.h>
#define MAX_DIGITAL 10001
#define MAX_LENGTH  50

// 反转int
int reverseDigital(int digital) {
    int temp = 0;
    while (digital > 0) {
        temp = temp * 10 + digital % 10;
        digital /= 10;
    }
    return temp;
}

// 判断数组里面表示的数是否是回文数
BOOL isPalindrome(int* arr, int length) {
    while (length > 0 && arr[--length] == 0);
    if (length < 0) return NO;
    for (int i=length; i>(length-1)/2; i--) {
        if (arr[i] != arr[length-i]) {
            return NO;
        }
    }
    return YES;
}

// 将数组里面表示的数，加上它的反转的数
void reverseAndAdd(int *arr, int length) {
    while (length > 0 && arr[--length] == 0);
    if (length < 0) return;
    for (int i=length; i>(length-1)/2; i--) {
        arr[i] += arr[length-i];
        arr[length-i] = arr[i];
    }
    // 进位
    for (int i=0; i<=length; i++) {
        if (arr[i]>=10) {
            arr[i+1] += arr[i]/10;
            arr[i] %= 10;
        }
    }
}

void printArr(int *arr, int length) {
    for (int i=0; i<length; i++) {
        printf("%d", arr[i]);
    }
    printf("\n");
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        int number[MAX_LENGTH] = {0};
        int count = 0;
        
        for (int i=1; i<MAX_DIGITAL; i++) {
            memset(number, 0, sizeof(int) * MAX_LENGTH);
            int temp = i;
            int j=0;
            while (temp>0) {
                number[j++] = temp%10;
                temp /= 10;
            }
            temp = 1;
            for (j=0; j<MAX_LENGTH; j++) {
                reverseAndAdd(number, MAX_LENGTH);
                if (isPalindrome(number, MAX_LENGTH)) {
                    temp = 0;
                    break;
                }
            }
            if (temp==1) {
                count ++;
                printf("%d, ", i);
            }
        }
        
        printf("\n");
        printf("%d\n", count);
    }
    return 0;
}
